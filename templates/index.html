{% extends "layout.html" %}

{% block title %}
  Hello World!
{% endblock %}

{% block content %}
  <style>
    section {
      height: calc(100vh - 52px);
      display: grid;
      grid-template-columns: minmax(200px, 1fr) 4fr;
    }
    aside {
      background-color: #abcdef;
      padding: 20px;
    }

    .menu-list button {
      background-color: transparent;
      border: none;
    }
    .menu-list button:hover {
      cursor: pointer;
    }

    #Menu-search-bar {
      padding: 8px 4px 8px 16px;
      margin-bottom: 0px;
    }

    .menu-input > .level-left {
      flex-grow: 1;
      flex-shrink: 1;
    }

    .menu-input .level-item {
      justify-content: flex-start;
      flex-grow: 1;
      flex-shrink: 1;
    }

    .menu-input input {
      border: none;
      width: 100%;
    }

    .menu-input button.is-rounded {
      height: 35px;
      width: 35px;
      padding: .1em .12em .1em .08em;
    }

    #Menu-search-bar button {
      padding: .5em;
      color: #9f9f9f;
    }

    #Menu-search-bar button:hover {
      background-color: transparent;
      color: #262626;
    }

    main {
      padding: 1em;
      height: calc(100vh - 52px);
      background-color: #eee;
      display: flex; 
      flex-direction: column;
    }

    #Chat-Input {
      padding-right: .5em;
      margin: .5em 0;
    }

    #Chat-Send {
      padding: .5em .8em .5em .6em;
      font-size: 14px;
      margin-left: .25em;
    }

    #Chat-Name, #Chat-Input {
      min-height: 50px;
    }
    #Chat-Convo {
      flex-grow: 1;
      background-color: #ddd;
      overflow-y: auto;
    }
    #Chat-Convo > div {
      overflow-wrap: break-word;
      max-width: 75vw;
    }

    @media screen and (max-width: 768px) {
      .level-left+.level-right {
        margin-top: 0rem;
      }
    }

    @media screen and (max-width: 600px) {
      section {
        grid-template-columns: 5fr;
      }
      aside {
        display:none;
      }
    }


  </style>

<section>
  <!-- Channel Aside -->
  <aside class="menu">
    <!-- Search Bar -->
    <p class="menu-label">
      Channels
    </p>
    <ul class="menu-list" id="Menu-Channels">
      <li>
        <div class="input is-rounded level menu-input" id="Menu-search-bar">
          <div class="control is-expanded level-left">
            <div class="level-item">
              <input type="text" placeholder="Search or create channel" id="Menu-search-value" class="is-danger">
            </div>
          </div>
          <div class="control level-right">
            <div class="level-item">
              <button id="Menu-search-Add">
                <i class="fas fa-plus"></i>
              </button>
              <button id="Menu-search-Search">
                <i class="fas fa-search"></i>
              </button>
            </div>
          </div>
        </div>
        <p class="help is-danger"></p>
      </li> 
      <div id="Menu-Channels-List">

      </div> 
    </ul>
    <hr>
    <!-- My channels -->
    <p class="menu-label">
      My Channels
    </p>
    <ul class="menu-list">
      <div id="Menu-My-Channels-List">

      </div>  
    </ul>
    <p class="menu-label">
      Friends
    </p>
  </aside>
  <main>
    <!-- Main channel or last channel -->
    <div id="Chat-Name"></div>
    <div id="Chat-Convo"></div>
    <div id="Chat-Input" class="input is-rounded level menu-input">
      <div class="control is-expanded level-left">
        <div class="level-item">
          <input type="text" placeholder="Say something here!">
          <p class="help is-danger"></p>
        </div>
      </div>
      <div class="control level-right">
        <div class="level-item">
          <button class="button is-rounded is-info">
              <i class="far fa-smile"></i>
          </button>
          <button class="button is-rounded is-info" id="Chat-Send">
              <i class="fas fa-paper-plane"></i>
          </button>
        </div>
      </div>
    </div>
  </main>
</section>
  
<script id="Template-Username" type="text/x-lodash-template">
  <div>
    <%= comment %>
  </div>
</script>

  <script id="Template-Modal" type="text/x-lodash-template">
    <div class="modal is-active" id="Index-PopUp">
      <div class="modal-background"></div>  
      <div class="modal-content">

        <div class="box">
          <article class="media">
            <div class="media-content">
              <div class="content">

                <p class="title is-3">Welcome to ChatRoom!</p>
                <p class="subtitle is-5">First time here? Enter username below to begin!</p>

                <div class="field">
                  <label class="label">Name</label>
                  <div class="control has-icons-left has-icons-right">
                    <input class="input" type="text" placeholder="Username">
                    <span class="icon is-small is-left">
                      <i class="fas fa-user"></i>
                    </span>
                    <p class="help is-danger"></p>
                  </div>
                </div>

                <div class="buttons is-right">
                  <div class="control">
                    <button class="button is-link">Submit</button>
                  </div>
                </div>

              </div>
            </div>
          </article>
        </div>

      </div>
    </div>
  </script>

  <script>
      // The app will store the userNAME into localStorage
      // Upon running, the app will retrieve user details from server
        // AND STORE USER OBJECT into USER_STATE
        // to keep memory in sync

      const templateFn = _.template(document.querySelector("#Template-Username").innerHTML);
      const channelContainer = document.querySelector("#Menu-Channels");
      const channelHead = document.querySelector("#Chat-Name");
      const channelConvo = document.querySelector("#Chat-Convo");

      const ChannelList = document.querySelector("#Menu-Channels-List");
      const MyChannelList = document.querySelector("#Menu-My-Channels-List");
      
      // https://cs50.harvard.edu/web/notes/5/
      const socket = io.connect(location.protocol + '//' + document.domain + ':' + location.port);

      document.addEventListener("DOMContentLoaded", function() {
      // USER VALIDATION
        // Returned users to be greeted
        if (storedUSERNAME) {
          // get User Object from server
          socket.emit("get user", storedUSERNAME);

          // server response
          socket.on("return user", userObj => {
            // Fallback in case of server problems
            if (userObj == "error") {
              // USER_STATE is updated inside the promise
              usernameModalManager(new User(new Date()));
                    
            } else {
              // Return userObj successful
              USER_STATE = userJSONConvert(userObj);

              document.querySelector("#Layout-Greeting").innerHTML = 
                templateFn({"comment": `Welcome back, ${USER_STATE.username}`});

              // TO BE REFACTORED
              // Channels attached to user are merely keys
              // Append the channels to sidebar
              
              if (USER_STATE.channels) {
                myChannels = USER_STATE.channels.filter(channelName => storedChannelName != channelName);

                console.log(myChannels, 269);

                if (myChannels.length) {
                  socket.emit("get channels", myChannels);
                }
              } 
            }
          });
        } else {
          // If first time, get unique username

          // new User Object
          // USER_STATE is updated inside the promise
          usernameModalManager(new User(new Date()));
        }

      // CHANNEL FUNCTIONALITIES
        // everytime a channel is shown
          // CHANNEL_STATE and localStorage will be updated
          // but it might not be added to USER_STATE
          // therefore it would be safer to render the 2 separately

        // Main window
        // Render only the screen 
        if (!storedChannelName) {
          let helpfulMsg = document.createElement("li");
            helpfulMsg.append("Click search to view full list of public channels!");

          MyChannelList.append(helpfulMsg);

          channelHead.textContent = "Welcome!";
          channelConvo.innerHTML = 
            templateFn({"comment": 
              "Start by searching a channel to join or create one yourself!"});
        } else {
          socket.emit("get last channel", storedChannelName);

          socket.on("last channel", channel => {
            if (channel) {
              channel = channelJSONConvert(channel);
              // It is possible that user clicked on a channel
                // but did not add channel to USER_OBJECT
              if (USER_STATE.channels.includes(channel.name)) {
                MyChannelList.append(channel.showChatList());
              }
              channel.showChat();
            } else {
              // server error or reset
              // in this branch CHANNEL_STATE is still not defined
              console.error("error 295 server error");
              localStorage.removeItem("channel");
              alert("Oh no! Something has went wrong! Please refresh the page!");

              channelConvo.innerHTML = 
                templateFn({"comment": 
                  "Start by searching a channel to join or create one yourself!"});
            }
          });
        }
      });
      // Onload event end
              
      socket.on("channel results", channelResults => {
        if (channelResults) {
          MyChannelList
          channelResults.forEach(channel => 
            MyChannelList.append(
              channelJSONConvert(channel).showChatList()
            )
          );
        } else {
          // server problem
          let helpfulMsg = document.createElement("li");
          helpfulMsg.append("Search for channels above!");

          MyChannelList.append(helpfulMsg);
        }
      });

      // Channel Functionalities

        // Create Channel
        const createChannel = document.querySelector("#Menu-search-Add");
        const searchChannel = document.querySelector("#Menu-search-Search");
        let searchBarValue;

        createChannel.addEventListener("click", function(event){
          event.preventDefault();
          SearchBarWarning(false);

          searchBarValue = document.querySelector("#Menu-search-value").value;

          if (searchBarValue) {
            // Check whether channel name used
            socket.emit("new channel attempt", searchBarValue); // Raw unvalidated string
          }
        });

        socket.on("channel create", channelCreateResult => {
          if (channelCreateResult) {
            if (!USER_STATE.channels.length) {
              MyChannelList.textContent = "";
            }
            channel = new Channel(searchBarValue, USER_STATE.username);
            
            // set CHANNEL_STATE and localStorage
            MyChannelList.append(channel.showChatList());
            channel.showChat();

            // announce to server on the creation
            socket.emit("new channel", JSON.stringify(CHANNEL_STATE));

            // and for User object
            USER_STATE.addChannel(CHANNEL_STATE);

            // reset box
            document.querySelector("#Menu-search-value").value = "";

          } else {
            // Channel Name used
            SearchBarWarning(true, "Name used!");
          }
        });

        // Search channels
        searchChannel.addEventListener("click", function(event){
          event.preventDefault();
          console.log("search, 375")

          searchBarValue = document.querySelector("#Menu-search-value").value;

          // get all channels if no string
          socket.emit("search channels", searchBarValue); // Search String
          document.querySelector("#Menu-search-value").value = "";
        });

        socket.on("channel search result", channelSearchResult => {
          if (!USER_STATE.channels.length) {
            MyChannelList.textContent = "";
          }

          if (channelSearchResult) {
            channelSearchResult
            .forEach(channelSearchItem => 
              MyChannelList.append(
                channelJSONConvert(channelSearchItem).showChatList()
              )
            );
          } else {
            SearchBarWarning(true, "No result found!");
          }
        });
      

      // Messaging Functionalities
      
        // Message in
        socket.on('message in', messageParcel => {
          if (messageParcel.channel == CHANNEL_STATE.name) {
            
            document.querySelector("#Chat-Convo").innerHTML += 
            `<div>
                <p>${messageParcel.author} at ${messageParcel.timeStamp}</p>
                <div>${messageParcel.message}</div>
              </div>`;
          } else {

          }
        });

        // TODO refeactored
        document.querySelector('#Chat-Input').addEventListener("keyup", function(event) {
          event.preventDefault();

          if (event.code == "Enter") {
            const message = document.querySelector("#Chat-Input input").value;

            if (message) {
              document.querySelector("#Chat-Input input").value = "";
              CHANNEL_STATE.messageHandler(new Message(USER_STATE.username, message, new Date(), CHANNEL_STATE));           
              USER_STATE.addChannel(CHANNEL_STATE);
            } else {
              // TODO
            }
          }
        });

        // Message out
        document.querySelector('#Chat-Send').addEventListener("click", function(event) {
          event.preventDefault();
          const message = document.querySelector("#Chat-Input input").value;

          if (message) {
            document.querySelector("#Chat-Input input").value = "";
            console.log(CHANNEL_STATE);
            CHANNEL_STATE.messageHandler(new Message(USER_STATE.username, message, new Date(), CHANNEL_STATE));           
            // Register channel under user if 1st time chatting
            USER_STATE.addChannel(CHANNEL_STATE);
          } else {
            // TODO
          }
        });

      class Message {
        constructor(username, message, timeStamp, channel) {
          this.author = username;
          this.message = message;
          this.hours = timeStamp.getHours();
          this.timeStamp = `${(this.hours % 12) < 10 ? "0" + (this.hours % 12) : (this.hours % 12)}.${timeStamp.getMinutes()}${this.hours >= 12 ? 'pm' : 'am'} ${timeStamp.toDateString()}`;
          this.channel = channel.name;
        }
      }

      class User {
        constructor(dateCreated) {
          this.username;
          this.dateCreated = dateCreated;
          this.channels = []; // channel names
        }

        getUsername(unvalidatedUsername) {
          let userHolder = this;

          // Send to server to validate
          let usernameCheck = new Promise(resolve => {
            socket.emit("new username", unvalidatedUsername);

            // Results
            socket.on("username result", function(result) {
              if (result == "not allowed") {
                resolve("Username used");
              } else {
                userHolder.username = unvalidatedUsername;
                resolve(false);
              }
            });
          });

          return usernameCheck;
        }

        addChannel(channel) {
          if (!this.channels.includes(channel.name)) {
            this.channels.push(channel.name);

            socket.emit("update user", JSON.stringify(this));
          }
        }

        removeChannel(channelObj) {
          
        }

        dataUpdate() {
        // Bundle the 3 together
          USER_STATE = this;

          socket.emit("new user", JSON.stringify(USER_STATE));

          // Store user object client side
          localStorage.setItem("user", USER_STATE.username);
        }
      }

      class Channel {
        constructor(name, owner) {
          this.name = name; // Name of channel
          this.owner = owner; // Creator
        }
      
        // Handle the viewing of chat details
        // fetch 20 per time
        showChat() {
          // somehow channelHead.textContent does not work 
            // even when the value is correctly updated
            // and will only work after a refresh
          document.querySelector("#Chat-Name").textContent = this.name;

          // Upon showing convo history, set channel as CHANNEL_STATE
          this.dataUpdate();
         

          socket.emit('get messages', this.name);

          socket.on('messages return', messageObjectArray => {
            if (messageObjectArray) {
              document.querySelector("#Chat-Convo").innerHTML = messageObjectArray
                .map(msg => 
                `<div>
                  <p>${msg.author} at ${msg.timeStamp}</p>
                  <div">${msg.message}</div>
                </div>`).join("");
             } else {
              document.querySelector("#Chat-Convo").innerHTML = "There is no message to be displayed. Start chatting!";
             }
          });
        }

        showChatList() {
          // display channel in sidebar
          let li = document.createElement("li");
          let button = document.createElement("button");
          let feed = document.createElement("span");
          
          li.append(button, feed);
          button.append(this.name);
          let channelHolder = this;

          let counter = 0;
          socket.on('message in', messageParcel => {
            console.log(messageParcel.channel, channelHolder.name, CHANNEL_STATE.name)
            if (messageParcel.channel == channelHolder.name && 
                messageParcel.channel != CHANNEL_STATE.name) {
              counter++;
              feed.className = "tag is-success";
              feed.innerHTML = counter;
            }
          });

          button.addEventListener("click", function(event) {
            event.preventDefault();
            console.log("button click", 505);

            channelHolder.showChat();

            counter = 0;
            feed.className = "";
            feed.innerHTML = "";
          });

          return li;
        }

        messageHandler(msgObj) {
          socket.emit("message out", msgObj);
        }

        dataUpdate() {
        // Bundle the 3 together
          if (CHANNEL_STATE != this) {
            CHANNEL_STATE = this;

            // Store user object client side
            localStorage.setItem("channel", CHANNEL_STATE.name);
            console.log(localStorage.getItem("channel"), 527);
          }
        }
      }

      // JSON convertor to User Objects
      function userJSONConvert(userParcel) {
        if (userParcel) {
          if (typeof userParcel == "string") {
            userParcel = JSON.parse(userParcel);
          }
          let returnedUser = new User(userParcel.dateCreated);
          returnedUser.username = userParcel.username;
          returnedUser.channels = userParcel.channels || {}; // blank object will be converted to undefined
          return returnedUser;
        } else {
          return userParcel;
        }
      }

      // JSON convertor to Channel Objects
      function channelJSONConvert(objParcel) {
        if (typeof objParcel == "string") {
          objParcel = JSON.parse(objParcel);
        }
        let returnedChannel = new Channel(objParcel.name, objParcel.owner);

        return returnedChannel;
      }

      // Always return a username string
      function UsernameWarning(toggle, status="") {
        const warningText = document.querySelector("#Index-PopUp .help");
        const warningBlock = document.querySelector("#Index-PopUp input");

        warningManager(warningBlock, warningText, toggle, status);
      }

      function SearchBarWarning(toggle, status="") {
        const searchBar = document.querySelector("#Menu-Channels .input");
        const searchWarning = document.querySelector("#Menu-Channels p");

        warningManager(searchBar, searchWarning, toggle, status);
      }

      function warningManager(warningNode, warningText, toggle, status) {
        // Clean up prior errors
        warningNode.classList.remove("is-danger");
        warningText.textContent = "";

        if (toggle) {
          console.log("warning 626");
          warningNode.classList.add("is-danger");
        } else {
          // turn off the warning
          warningNode.classList.remove("is-danger");
        }
        warningText.textContent = status;
      }

      function usernameModalManager(user) {
        const usernameModal = document.querySelector("#Template-Modal").innerHTML;
      
        // Force pop up
        document.querySelector("main").innerHTML += usernameModal;

        // get unvalidated username
        document.querySelector("#Index-PopUp button")
          .addEventListener("click", function(event) {
            event.preventDefault();

            // Remove prior errors if any
            UsernameWarning(false);

            // retrieve raw value
            const unvalidatedUsername = document.querySelector("#Index-PopUp input").value;
            
            // Client side validation
            if (!unvalidatedUsername) {
              UsernameWarning(true, "Please enter a valid name");

            } else {
              // pass the username to User Object to validate with server
              let serverValidateResult = new Promise((resolve, reject) => {
                resolve(user.getUsername(unvalidatedUsername))});
            
              serverValidateResult.then(result => {
                if (result) {
                  UsernameWarning(true, result);
                  return false;
                } else {
                  // Success
                  document.querySelector("#Index-PopUp").classList.remove("is-active");
                  return unvalidatedUsername;
                }})
              .then(validatedUsername => {
                
                  if (validatedUsername){
                    // update data and sync to server
                    user.dataUpdate();

                    document.querySelector("#Layout-Greeting").innerHTML = 
                      templateFn({"comment": `Hi, ${validatedUsername}`});
                  }

                })
              .catch(error => UsernameWarning(true, "Please refresh the page and try again!"));
            }
          }
        );
      }

    </script>


{% endblock %}

  

  
